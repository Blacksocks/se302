# TP STM32

## Description

The goal of this project is to install and use ChibiOS on a STM32-E407 board.
We have to use basic I/O as LED, USB and finally Ethernet.

## 1st step: Compiling basic program using ChibiOS

### Download ChibiOS

ChibiOS meaning: ちび means small [link](http://chibios.sourceforge.net/docs3/rt/index.html)

I downloaded ChibiOS from this [link](https://sourceforge.net/projects/chibios/files/?SetFreedomCookie)  
and created my project next to ChibiOS folder.

### Project architecture

To don't begin from scratch, I used demo project:
```bash
<ChibiOS>/demos/<proc_familly>/<board>/
```
I copied this files in my project
> chconf.h  
 halconf.h  
 mcuconf.h  
 Makefile

I created a basic main.c program into a src/
```c
int main(void) {
    while(1);
}
```

Then, I changed pin configuration by copying this folder into my project:
```bash
<ChibiOS>/os/hal/boards/<board>/
```
and modifying board.h and board.mk  
board.mk:
```c
BOARDSRC = board_E407/board.c
BOARDINC = board_E407
```

### Compiling using ChibiOS

To link my own files to compilation, I changed Makefile:
```c
CHIBIOS = ../ChibiOS        # set chibios folder
...
CSRC = ... \
       src/main.c           # add own main program
...
include board_E407/board.mk # link my board configuration
```
Doing ```make``` created an executable file <project>.elf

## 2st step: Runing basic program using ChibiOS

### J-Link

To run program on board, I used J-Link debugger.  
I used this command to run JLinkGDBServer:

```bash
pidof JLinkGDBServer > /dev/null || JLinkGDBServer -if swd -speed auto -device STM32F405ZG
```
And these ones in another terminal:
```bash
arm-none-eabi-gdb build/<project>.elf
split     # use user friendly interface
load      # load program in flash
mon reset # reset CPU
c         # run program
q         # quit
```

## 3rd step: Use ChibiOS init functions

Add init functions into main.c:
```c
#include "ch.h"
#include "hal.h"

int main(void)
{
    halInit();
    chSysInit();
    while(1);
}
```

If while loop is not reached during execution on board, there is probably an error.  
I had an error using Olimex-STM32-E407 ([soluce](http://www.chibios.com/forum/viewtopic.php?t=1040))  
Into GDB, display position into c code using ```layout n``` and then ```print <variable>``` to show error.  
I personally had to set ```HAL_USE_MAC``` to ```false``` into ```halconf.h```.

## 4th step: LED blinking

### LED on

In order to switch on LED, I configured LED pin:
```c
palSetPadMode(GPIOC, GPIOC_LED, PAL_MODE_OUTPUT_PUSHPULL)
```
I used ```PAL_MODE_OUTPUT_PUSHPULL``` because I wanted output either connected to VCC or to GND, no floating state.

According to electrical schematic, I set this pin to high level:
```c
palClearPad(GPIOC, GPIOC_LED)
```

## 5th step: LED PWM

In order to change LED intensity, I used PWM driver.  
PWM driver is usually used to control hardware intensity.  
Here, our LED is not connected to pin with PWM.  
Therefore I used callbacks generated by PWM driver to quickly toggle LED.  
I configured driver to call callbacks each rising and falling edge of PWM.  

I had a problem using PWM driver. I set frequency to 1000Hz but I had an error.  
I found that this assertion must be verified:

> (pwmp->clock / pwmp->config->frequency) - 1 <= 0xFFFF  
> pwmp->clock = 84000000  
> Therefore frequency must be over 1282Hz.

My second problem was callbacks. They was never called.  
A found that two functions must be called to activate callbacks:
```c
pwmEnableChannelNotification(&PWMD3, 0);
pwmEnablePeriodicNotification(&PWMD3);
```
Moreover, these functions must be used in this order.

## 6th step: Serial communication via USB

### Initialization

The first task is to describe USB connection. USB is a very complex protocol and configuration is difficult.  
Therefore, I used ```usbcfg.h``` and ```usbcfg.c``` from an example to configure USB.  
I also configured USB ports as in the example. I only changed configuration of ports connected to USB_TOG1.

### Communication

To test communication, I just made a program who send a character at most each 2s.  
This character change if a new character is received.
```c
unsigned char c = 'A';
int input;
while(1){
    chnPutTimeout(&SDU1, c, MS2ST(500));
    if((input = chnGetTimeout(&SDU1, MS2ST(2000))) != Q_TIMEOUT)
        c = (unsigned char)input;
    chThdSleepMilliseconds(10);
}
```
I noticed that at the beginning of the communication some strange characters are received by USB.

### Shell

To implement the shell, I imagined to:
* recode an entire shell using only write and read methods (```chnWrite()``` and ```chnRead()```)
* use whole example in Chibi documentation
* use Chibi's shell function (don't used in documentation)

I choose the third idea but I had a lot of problem for making the shell run.  
I finally understood that after serial port connection, some data are send through USB for initialization.  
During this time, shell cannot be run.  
To prevent this delay, I deactivated ModemManager:
```bash
sudo stop modemmanager
```

This method have a huge problem: if we do not read COM port in the first ~6s, we cannot access to the shell!  
To correct this issue, I used a thread started in a loop (as done in the example).  
The program will try to start a shell until it success. Then, it wait the end of the shell to start another one.

## RTT

### First connection

To use RTT, I first need to start JLink program. It starts a server which allows to use JLink functionalities.
```bash
JLinkExe -if SWD -device STM32F405ZG -speed 4000
```

Then, I use Telnet to connect to this server and use JLink functions. I found the (default) address into SEGGER JLink User Manual (at ```-RTTTelnetPort```).
```bash
telnet localhost 19021
```
After running my first program,
```c
while(1)
{
    SEGGER_RTT_WriteString(0, "Hello World from SEGGER!\r\n");
    chThdSleepMilliseconds(1000);
}
```
and running it using GDB, I saw the expected message in the Telnet terminal.

In order to use RTT as a stream (```BaseSequentialStream``` in ChibiOS), I created a variable which implements each basic stream functions based on SEGGER_RTT functions:
* rtt_write
* rtt_read
* rtt_put
* rtt_get

I now use RTT to communicate with the board using shell:
```c
ShellConfig shell_cfg1 = {
    // Stream where data are send/received
    // RTT_stream to use RTT
    // SDU1       to use Serial over USB
    (BaseSequentialStream *) &RTT_stream,
    // Commands structure
    commands
};
```
