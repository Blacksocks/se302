# TP STM32

## Description

The goal of this project is to install and use ChibiOS on a STM32-E407 board.
We have to use basic I/O as LED, USB and finally Ethernet.

## 1st step: Compiling basic program using ChibiOS

### Download ChibiOS

ChibiOS meaning: ちび means small [link](http://chibios.sourceforge.net/docs3/rt/index.html)

I downloaded ChibiOS from this [link](https://sourceforge.net/projects/chibios/files/?SetFreedomCookie)  
and created my project next to ChibiOS folder.

### Project architecture

To don't begin from scratch, I used demo project:
```
<ChibiOS>/demos/<proc_familly>/<board>/
```
I copied this files in my project
> chconf.h  
> halconf.h  
> mcuconf.h  
> Makefile

I created a basic main.c program into a src/
```c
int main(void) {
    while(1);
}
```

Then, I changed pin configuration by copying this folder into my project:
```
<ChibiOS>/os/hal/boards/<board>/
```
and modifying board.h and board.mk  
board.mk:
```
BOARDSRC = board_E407/board.c
BOARDINC = board_E407
```

### Compiling using ChibiOS

To link my own files to compilation, I changed Makefile:
```
CHIBIOS = ../ChibiOS        # set chibios folder
...
CSRC = ... \
       src/main.c           # add own main program
...
include board_E407/board.mk # link my board configuration
```
Doing ```make``` created an executable file <project>.elf

## 2st step: Runing basic program using ChibiOS

### J-Link

To run program on board, I used J-Link debugger.  
I used this command to run JLinkGDBServer:
```
pidof JLinkGDBServer > /dev/null || JLinkGDBServer -if swd -speed auto -device STM32F405ZG
```
And these ones in another terminal:
```
arm-none-eabi-gdb build/<project>.elf
split     # use user friendly interface
load      # load program in flash
mon reset # reset CPU
c         # run program
q         # quit
```

## 3rd step: Use ChibiOS init functions

Add init functions into main.c:
```c
#include "ch.h"
#include "hal.h"

int main(void)
{
    halInit();
    chSysInit();
    while(1);
}
```

If while loop is not reached during execution on board, there is probably an error.  
I had an error using Olimex-STM32-E407 ([soluce](http://www.chibios.com/forum/viewtopic.php?t=1040))  
Into GDB, display position into c code using ```layout n``` and then ```print <variable>``` to show error.  
I personally had to set ```HAL_USE_MAC``` to ```false``` into ```halconf.h```.

## 4th step: LED blinking

### LED on

In order to switch on LED, I configured LED pin:
```c
palSetPadMode(GPIOC, GPIOC_LED, PAL_MODE_OUTPUT_PUSHPULL)
```
I used ```PAL_MODE_OUTPUT_PUSHPULL``` because I wanted output either connected to VCC or to GND, no floating state.

According to electrical schematic, I set this pin to high level:
```c
palClearPad(GPIOC, GPIOC_LED)
```

## 5th step: LED PWM

In order to change LED intensity, I used PWM driver.  
PWM driver is usually used to control hardware intensity.  
Here, our LED is not connected to pin with PWM.  
Therefore I used callbacks generated by PWM driver to quickly toggle LED.  
I configured driver to call callbacks each rising and falling edge of PWM.  

I had a problem using PWM driver. I set frequency to 1000Hz but I had an error.  
I found that this assertion must be verified:

> (pwmp->clock / pwmp->config->frequency) - 1 <= 0xFFFF
> pwmp->clock = 84000000
> Therefore frequency must be over 1282Hz.

My second problem was callbacks. They was never called.  
A found that two functions must be called to activate callbacks:
```c
pwmEnableChannelNotification(&PWMD3, 0);
pwmEnablePeriodicNotification(&PWMD3);
```
Moreover, these functions must be used in this order.

## 6th step: Serial communication via USB

### Initialization

The first task is to describe USB connection. USB is a very complex protocol and configuration is difficult.  
Therefore, I used ```usbcfg.h``` and ```usbcfg.c``` from an example to configure USB.  
I also configured USB ports as in the example. I only changed configuration of ports connected to USB_TOG1.

### Communication

To test communication, I just made a program who send a character at most each 2s.  
This character change if a new character is received.
```c
unsigned char c = 'A';
int input;
while(1){
    chnPutTimeout(&SDU1, c, MS2ST(500));
    if((input = chnGetTimeout(&SDU1, MS2ST(2000))) != Q_TIMEOUT)
        c = (unsigned char)input;
    chThdSleepMilliseconds(10);
}
```
I noticed that at the beginning of the communication come strange characters are received by USB.

### Shell
